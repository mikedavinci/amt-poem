//+------------------------------------------------------------------+
//|                                                   SignalReader.mq4  |
//|                                                                    |
//+------------------------------------------------------------------+
#property copyright "Miguel Esparza mikedavinci"
#property link      "TradeJourney.ai"
#property version   "1.00"
#property strict

// External parameters
extern string API_URL = "https://api.tradejourney.ai/api/alerts/mt4-forex-signals";  // API URL
extern int    REFRESH_MINUTES = 60;                    // How often to check for new signals
extern bool   DEBUG_MODE = true;                      // Print debug messages
extern string PAPERTRAIL_HOST = "https://api.tradejourney.ai/api/alerts/log"; // API endpoint for logs
extern string SYSTEM_NAME = "EA-TradeJourney";                     // System identifier
extern bool   ENABLE_PAPERTRAIL = true;                    // Enable/disable Papertrail logging
extern bool   ENABLE_PROFIT_PROTECTION = true;           // Enable/disable profit protection
extern int    PROFIT_CHECK_INTERVAL = 60;               // How often to check profit protection (in seconds)
extern double FOREX_PROFIT_PIPS_THRESHOLD = 20;         // Minimum profit in pips before protection
extern double FOREX_PROFIT_LOCK_PIPS = 10;              // How many pips to keep as profit
extern double CRYPTO_PROFIT_THRESHOLD = 1.0;            // Minimum profit percentage before protection
extern double CRYPTO_PROFIT_LOCK_PERCENT = 0.5;         // Percentage of profit to protect
extern double FOREX_STOP_PIPS = 50;        // Stop loss in pips for forex pairs
extern double CRYPTO_STOP_PERCENT = 2.0;    // Stop loss percentage for crypto pairs
extern double RISK_PERCENT = 1.0;           // Risk percentage per trade
extern int    MAX_POSITIONS = 1;                     // Maximum positions per symbol
extern int    MAX_RETRIES = 3;                       // Maximum retries for failed trades
extern double FOREX_EMERGENCY_PIPS = 75;     // Emergency close level for forex (in pips)
extern int    EMERGENCY_CLOSE_PERCENT = 3;          // Emergency close if loss exceeds this percentage
extern double MAX_ACCOUNT_RISK_PERCENT = 3.0;  // Maximum total account risk (3x RISK_PERCENT)
extern double MAX_SYMBOL_RISK_PERCENT = 2.0;   // Maximum risk per symbol (2x RISK_PERCENT)
extern int    MAX_SLIPPAGE = 5;                      // Maximum allowed slippage in points
extern int    PRICE_DIGITS = 5;                      // Decimal places for price display (5 for forex, 3 for JPY pairs)
extern string TIMEFRAME = "60";                      // Timeframe parameter for API

extern bool   TRADE_ASIAN_SESSION = true;          // Allow trading during Asian session
extern bool   TRADE_LONDON_SESSION = true;         // Allow trading during London session
extern bool   TRADE_NEWYORK_SESSION = true;        // Allow trading during New York session
extern bool   ALLOW_SESSION_OVERLAP = true;        // Allow trading during session overlaps

// Custom Error Codes (start at high number to avoid conflicts)
#define ERR_CUSTOM_START           65536
#define ERR_CUSTOM_ERROR          (ERR_CUSTOM_START + 1)
#define ERR_AUTHORIZATION         (ERR_CUSTOM_START + 3)

// Global variables
datetime lastCheck = 0;
string lastSignalTimestamp = "";

// Structure to hold signal data
struct SignalData {
   string ticker;
   string action;
   double price;
   double stopLoss;
   double takeProfit;
   string timestamp;
   string pattern;
};

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit() {
   // Add your symbol to MarketWatch if not already there
   SymbolSelect("EURUSD+", true);
   SymbolSelect("AUDUSD+", true);
   SymbolSelect("GBPUSD+", true);
   //SymbolSelect("USDJPY+", true);
   SymbolSelect("BTCUSD", true); 
   SymbolSelect("ETHUSD", true);
   SymbolSelect("LTCUSD", true);

   
   LogInfo("EA Initialized with Risk: " + DoubleToString(RISK_PERCENT, 2) + "%");
   LogInfo("Account Balance: " + DoubleToString(AccountBalance(), 2));
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
   LogInfo("EA Deinitialized. Reason: " + IntegerToString(reason));
}

//+------------------------------------------------------------------+
//| Helper function to escape JSON strings                             |
//+------------------------------------------------------------------+
string EscapeJsonString(string str) {
    string result = str;
    StringReplace(result, "\"", "\\\"");
    StringReplace(result, "\n", "\\n");
    StringReplace(result, "\r", "\\r");
    return result;
}

//+------------------------------------------------------------------+
//| Send Log to Papertrail                                            |
//+------------------------------------------------------------------+
void SendToPapertrail(string message, string level = "INFO", string symbol = "") {
    if (!ENABLE_PAPERTRAIL) {
        Print("Papertrail disabled - skipping log: ", message);
        return;
    }
    
    // Convert MT4 log level to API level
    string apiLevel;
    if (level == "ERROR") apiLevel = "error";
    else if (level == "WARNING") apiLevel = "warn";
    else apiLevel = "info";
    
    // Format timestamp in ISO 8601 format
    datetime currentTime = TimeCurrent();
    string isoTimestamp = StringFormat(
        "%d-%02d-%02dT%02d:%02d:%02dZ",
        TimeYear(currentTime),
        TimeMonth(currentTime),
        TimeDay(currentTime),
        TimeHour(currentTime),
        TimeMinute(currentTime),
        TimeSeconds(currentTime)
    );
    
    // Ensure symbol is not empty
    if(symbol == "") symbol = Symbol();
    
    // Build metadata object with enhanced information
    string metadata = StringFormat(
        "{\"system\":\"%s\",\"timestamp\":\"%s\",\"level\":\"%s\",\"account\":%d,\"symbol\":\"%s\",\"timeframe\":\"%s\"}",
        SYSTEM_NAME,
        isoTimestamp,
        level,
        AccountNumber(),
        symbol,
        TIMEFRAME
    );
    
    // Build the complete payload
    string payload = StringFormat(
        "{\"message\":\"%s\",\"level\":\"%s\",\"metadata\":%s}",
        EscapeJsonString(message),
        apiLevel,
        metadata
    );
    
    string headers = "Content-Type: application/json\r\n";
    char post[];
    ArrayResize(post, StringLen(payload));
    StringToCharArray(payload, post, 0, StringLen(payload));
    
    char result[];
    string resultHeaders;
    
    ResetLastError();
    int res = WebRequest(
        "POST",
        PAPERTRAIL_HOST,
        headers,
        5000,
        post,
        result,
        resultHeaders
    );
    
    if(res == -1) {
        int error = GetLastError();
        if(error == 4060) {
            Print("ERROR: Enable WebRequest for URL: ", PAPERTRAIL_HOST);
            Print("Add URL to MetaTrader -> Tools -> Options -> Expert Advisors -> Allow WebRequest");
            return;
        }
        Print("Failed to send log. Error: ", error, " - ", ErrorDescription(error));
    } else {
        string response = CharArrayToString(result, 0, ArraySize(result));
        if(DEBUG_MODE) Print("Log sent successfully. Response: ", response);
    }
}

//+------------------------------------------------------------------+
//| Enhanced Debug Print Function with Papertrail Integration          |
//+------------------------------------------------------------------+
void PrintDebug(string message, string level = "INFO", string symbol = "") {
    string formattedMessage = TimeToString(TimeCurrent()) + " | " + 
                             (symbol == "" ? Symbol() : symbol) + " | " + message;
    
    SendToPapertrail(message, level, symbol);
    
    if(DEBUG_MODE) {
        Print(formattedMessage);
    }
}

//+------------------------------------------------------------------+
//| Logging Helper Functions                                           |
//+------------------------------------------------------------------+
void LogError(string message, string symbol = "") {
    PrintDebug(message, "ERROR", symbol);
}

void LogWarning(string message, string symbol = "") {
    PrintDebug(message, "WARNING", symbol);
}

void LogInfo(string message, string symbol = "") {
    PrintDebug(message, "INFO", symbol);
}

void LogDebug(string message, string symbol = "") {
    PrintDebug(message, "DEBUG", symbol);
}

void LogTrade(string message, string symbol = "") {
    PrintDebug(message, "TRADE", symbol);
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick() {
   // First, check for any positions that need emergency closing
   CheckEmergencyClose();

   MonitorRiskLevels();
   
   if (!IsTimeToCheck()) return;

   // LogAccountStatus();
   // LogDailyPerformance();
   
   string currentSymbol = Symbol();
   // LogMarketConditions(currentSymbol);
   // LogTradingVolume(currentSymbol);

   // Check if market is open before proceeding
   if(!IsMarketOpen(currentSymbol)) {
      LogDebug("Market closed or outside trading hours for " + currentSymbol);
      return;
   }
   
   // Check if we're in an acceptable trading session
   if(!IsMarketSessionActive(currentSymbol)) {
      LogDebug("Outside allowed trading session for " + currentSymbol);
      return;
   }
   
   LogDebug("Checking for new signals on " + currentSymbol + 
            " @ " + DoubleToString(MarketInfo(currentSymbol, MODE_BID), PRICE_DIGITS));

   string apiSymbol = GetBaseSymbol(currentSymbol);
   string url = StringFormat("%s?pairs=%s&tf=%s", API_URL, apiSymbol, TIMEFRAME);
   
   LogDebug("Checking for new signals: " + currentSymbol);
   
   string response = FetchSignals(url);
    if (response == "") {
      LogError("Empty response from signal API");
      return;
   }
   
   SignalData signal;
   if (ParseSignal(response, signal)) {
      ProcessSignal(signal);
   }
   
   lastCheck = TimeCurrent();
   
   // Check profit protection after processing new signals
   if(ENABLE_PROFIT_PROTECTION) {
      CheckProfitProtection();
   }
}

//+------------------------------------------------------------------+
//| Check if it's time to refresh signals                             |
//+------------------------------------------------------------------+
bool IsTimeToCheck() {
   datetime currentTime = TimeCurrent();
   return (currentTime >= lastCheck + REFRESH_MINUTES * 60);
}

//+------------------------------------------------------------------+
//| Fetch signals from API                                            |
//+------------------------------------------------------------------+
string FetchSignals(string url) {
   string headers = "Content-Type: application/json\r\n";
   char post[];
   char result[];
   string resultHeaders;
   
   int res = WebRequest(
      "GET",                   // Method
      url,                     // URL
      headers,                 // Headers
      5000,                    // Timeout
      post,                    // POST data
      result,                  // Server response
      resultHeaders            // Response headers
   );
   
   if(res == -1) {
      int errorCode = GetLastError();
      LogError("Error in WebRequest. Error code: " + IntegerToString(errorCode));
      return "";
   }
   
   string response = CharArrayToString(result);
   LogDebug("API Response: " + response);
   return response;
}

//+------------------------------------------------------------------+
//| Parse JSON signal                                                 |
//+------------------------------------------------------------------+
bool ParseSignal(string &jsonString, SignalData &signal) {
   // Remove array brackets if present
   string json = jsonString;
   if (StringGetChar(json, 0) == '[') {
      json = StringSubstr(json, 1, StringLen(json) - 2);
   }
   
    if (StringFind(json, "ticker") < 0) {
      LogError("Invalid signal format - missing ticker");
      return false;
   }
   
      // Extract and validate required fields
   string ticker = GetJsonValue(json, "ticker");
   string action = GetJsonValue(json, "action");
   string price = GetJsonValue(json, "price");
   string timestamp = GetJsonValue(json, "timestamp");
   
   // Validate required fields
   if(ticker == "" || action == "" || price == "" || timestamp == "") {
      LogError("Missing required signal fields");
      return false;
   }
   
   // Validate action type
   if(action != "BUY" && action != "SELL" && action != "NEUTRAL") {
      LogError("Invalid action type: " + action);
      return false;
   }
   
   // Format ticker based on pair type
   signal.ticker = (StringFind(ticker, "BTC") >= 0 || 
                   StringFind(ticker, "ETH") >= 0 || 
                   StringFind(ticker, "LTC") >= 0) ? ticker : ticker + "+";
   
   // Validate symbol exists
   if(MarketInfo(signal.ticker, MODE_BID) == 0) {
      LogError("Invalid symbol in signal: " + signal.ticker);
      return false;
   }
   
   // Set signal data
   signal.action = action;
   signal.price = StringToDouble(price);
   signal.timestamp = timestamp;
   signal.pattern = GetJsonValue(json, "signalPattern");
   
   // Additional validation
   if(signal.price <= 0) {
      LogError("Invalid price in signal: " + price);
      return false;
   }
   
   bool isCryptoPair = (StringFind(signal.ticker, "BTC") >= 0 || 
                       StringFind(signal.ticker, "ETH") >= 0 || 
                       StringFind(signal.ticker, "LTC") >= 0);
   
   int digits = isCryptoPair ? 2 : (StringFind(signal.ticker, "JPY") >= 0 ? 3 : 5);
   
   LogDebug(StringFormat(
      "Signal Parsed Successfully:" +
      "\nSymbol: %s" +
      "\nAction: %s" +
      "\nPrice: %.*f" +
      "\nPattern: %s" +
      "\nTimestamp: %s",
      signal.ticker,
      signal.action,
      digits, signal.price,
      signal.pattern,
      signal.timestamp
   ));
   
   return true;
}

//+------------------------------------------------------------------+
//| Calculate position size based on risk and stop loss                |
//+------------------------------------------------------------------+
double CalculatePositionSize(string symbol, double entryPrice, double stopLoss) {
    // 1. Calculate maximum risk amount based on account balance
    double accountBalance = AccountBalance();
    double maxRiskAmount = accountBalance * (RISK_PERCENT / 100);
    
    // 2. Calculate stop loss distance in price terms
    double stopDistance = MathAbs(entryPrice - stopLoss);
    
    if(stopDistance == 0) {
        LogError("Error: Stop loss distance cannot be zero");
        return 0;
    }
    
    // 3. Identify pair type
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0);
    bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
    
    // Debug initial calculation parameters
    LogDebug(StringFormat(
        "Position Size Calculation Starting:" +
        "\nSymbol: %s" +
        "\nAccount Balance: $%.2f" +
        "\nRisk Amount: $%.2f" +
        "\nEntry Price: %.5f" +
        "\nStop Loss: %.5f" +
        "\nStop Distance: %.5f",
        symbol, accountBalance, maxRiskAmount, entryPrice, stopLoss, stopDistance
    ));
    
    // 4. Calculate position size
    double lotSize;
    
    if(isCryptoPair) {
        // NEW CRYPTO CALCULATION
        // Calculate value of 1 lot in USD
        double oneUnitValue = entryPrice;

        // Calculate dollar risk per lot
        double riskPerLot = stopDistance;  // Dollar risk for 1 full unit
        
        // Initial lot size based on risk
        lotSize = maxRiskAmount / riskPerLot;
        
        // SAFETY CHECKS FOR CRYPTO
        // Maximum position value should align with RISK_PERCENT
        double maxPositionValue = AccountEquity() * (RISK_PERCENT * 2 / 100);  // 2x RISK_PERCENT
        double maxLotsBasedOnEquity = maxPositionValue / oneUnitValue;
        
        // 2. Maximum position based on available margin with 200% margin reserve
        double marginRequired = MarketInfo(symbol, MODE_MARGINREQUIRED);
        if(marginRequired > 0) {
            double maxLotsBasedOnMargin = AccountFreeMargin() / (marginRequired * 1.5);  // 150% margin reserve
            maxLotsBasedOnEquity = MathMin(maxLotsBasedOnEquity, maxLotsBasedOnMargin);
        }
        
        // Take the minimum of risk-based size and safety limits
        lotSize = MathMin(lotSize, maxLotsBasedOnEquity);

        LogDebug(StringFormat(
            "Crypto Position Size Calculation:" +
            "\nOne Unit Value: $%.2f" +
            "\nRisk Per Lot: $%.2f" +
            "\nInitial Size: %.4f" +
            "\nMax Size Based on Equity: %.4f" +
            "\nFinal Size: %.4f",
            oneUnitValue,
            riskPerLot,
            maxRiskAmount / riskPerLot,
            maxLotsBasedOnEquity,
            lotSize
        ));
    } else {
        // FOREX CALCULATION (unchanged)
        double point = MarketInfo(symbol, MODE_POINT);
        double tickValue = MarketInfo(symbol, MODE_TICKVALUE);
        double stopPoints = stopDistance / point;
        double pipValue;
        
        if(isJPYPair) {
            pipValue = tickValue * 100;
            stopPoints = stopPoints / 100;
        } else {
            pipValue = tickValue * 10;
            stopPoints = stopPoints / 10;
        }
        
        lotSize = maxRiskAmount / (stopPoints * pipValue);
        
        LogDebug(StringFormat(
            "Forex Position Size:" +
            "\nStop Distance (pips): %.1f" +
            "\nPip Value: $%.2f" +
            "\nCalculated Lots: %.2f",
            stopPoints, pipValue, lotSize
        ));
    }
    
    // 5. Apply broker constraints
    double minLot = MarketInfo(symbol, MODE_MINLOT);
    double maxLot = MarketInfo(symbol, MODE_MAXLOT);
    double lotStep = MarketInfo(symbol, MODE_LOTSTEP);
    
    // Round down to broker's lot step
    lotSize = MathFloor(lotSize / lotStep) * lotStep;
    
    // Ensure within broker's limits
    lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
    
    // Calculate actual risk with final position size
    double actualRisk;
    if(isCryptoPair) {
        actualRisk = lotSize * stopDistance;
    } else {
        double stopPoints = stopDistance / MarketInfo(symbol, MODE_POINT);
        double pipValue = isJPYPair ? MarketInfo(symbol, MODE_TICKVALUE) * 100 : 
                                    MarketInfo(symbol, MODE_TICKVALUE) * 10;
        actualRisk = lotSize * (stopPoints / (isJPYPair ? 100 : 10)) * pipValue;
    }
    
    double riskPercent = (actualRisk / accountBalance) * 100;
    
    // Final position size check - if risk is too high, return 0
    if(riskPercent > RISK_PERCENT * 1.1) {  // Allow 10% buffer over target risk
        LogError(StringFormat(
            "Position size rejected - Risk too high:" +
            "\nCalculated Risk: %.2f%%" +
            "\nMaximum Allowed: %.2f%%",
            riskPercent, RISK_PERCENT
        ));
        return 0;
    }
    
    LogDebug(StringFormat(
        "Final Position Size:" +
        "\nSymbol: %s" +
        "\nFinal Lots: %.2f" +
        "\nActual Risk: $%.2f (%.2f%%)" +
        "\nPosition Value: $%.2f",
        symbol,
        lotSize,
        actualRisk,
        riskPercent,
        lotSize * entryPrice
    ));
    
    return lotSize;
}

//+------------------------------------------------------------------+
//| Calculate Stop Loss price based on pair type                       |
//+------------------------------------------------------------------+
double CalculateStopLoss(string symbol, int cmd, double entryPrice) {
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0);
    bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
    
    double stopLoss;
    
    if(isCryptoPair) {
        // Percentage-based stop for crypto
        if(cmd == OP_BUY) {
            stopLoss = entryPrice * (1 - CRYPTO_STOP_PERCENT/100);
        } else {
            stopLoss = entryPrice * (1 + CRYPTO_STOP_PERCENT/100);
        }
        
        LogDebug(StringFormat(
            "Crypto Stop Loss:" +
            "\nEntry: %.2f" +
            "\nStop Loss: %.2f" +
            "\nStop Percent: %.2f%%",
            entryPrice, stopLoss, CRYPTO_STOP_PERCENT
        ));
    } else {
        // Pip-based stop for forex
        double pipSize = isJPYPair ? 0.01 : 0.0001;
        
        if(cmd == OP_BUY) {
            stopLoss = entryPrice - (FOREX_STOP_PIPS * pipSize);
        } else {
            stopLoss = entryPrice + (FOREX_STOP_PIPS * pipSize);
        }
        
        LogDebug(StringFormat(
            "Forex Stop Loss:" +
            "\nEntry: %.5f" +
            "\nStop Loss: %.5f" +
            "\nStop Pips: %.1f",
            entryPrice, stopLoss, FOREX_STOP_PIPS
        ));
    }
    
    return stopLoss;
}

//+------------------------------------------------------------------+
//| Process trading signal                                            |
//+------------------------------------------------------------------+
void ProcessSignal(SignalData &signal) {

   if(MarketInfo(signal.ticker, MODE_BID) == 0) {
      LogError("Error: Invalid symbol " + signal.ticker);
      return;
   }

   if (signal.timestamp == lastSignalTimestamp) {
      LogDebug("Signal already processed for: " + signal.timestamp);
      return;
   }
   
   // Check if market is open before processing signal
   if(!IsMarketOpen(signal.ticker)) {
      LogDebug("Market closed for " + signal.ticker + " - signal not processed");
      return;
   }
   
   int cmd = -1;
   if (signal.action == "BUY") cmd = OP_BUY;
   else if (signal.action == "SELL") cmd = OP_SELL;
   else {
      LogDebug("NEUTRAL signal received - no action taken");
      return;
   }
    // Get current market prices
   double ask = MarketInfo(signal.ticker, MODE_ASK);
   double bid = MarketInfo(signal.ticker, MODE_BID);
   double price = cmd == OP_BUY ? ask : bid;
   
   // Handle existing positions first
   if (HasOpenPosition(signal.ticker)) {
      int currentPositionType = GetOpenPositionType(signal.ticker);
      bool shouldClose = false;
      
      // Close if opposite signal received
      if ((cmd == OP_BUY && currentPositionType == OP_SELL) || 
          (cmd == OP_SELL && currentPositionType == OP_BUY)) {
          shouldClose = true;
          LogTrade(StringFormat(
              "Reverse signal received for %s\n" +
              "Current Position: %s\n" +
              "New Signal: %s\n" +
              "Attempting to close current position...",
              signal.ticker,
              currentPositionType == OP_BUY ? "BUY" : "SELL",
              signal.action
          ));
      }
      
      if(shouldClose) {
          if (!CloseCurrentPosition(signal.ticker)) {
              LogError(StringFormat(
                  "Failed to close existing %s position for %s - new position will not be opened",
                  currentPositionType == OP_BUY ? "BUY" : "SELL",
                  signal.ticker
              ));
              return;
          }
      } else {
          LogDebug("Position already exists in same direction - no action taken");
          return;
      }
   }
   
   // Risk management check
   if(!CanOpenNewPosition(signal.ticker)) {
      LogDebug("Risk management prevented opening new position");
      return;
   }
   
   // Calculate stop loss using our new function
   double sl = CalculateStopLoss(signal.ticker, cmd, price);

    // Validate risk before calculating position size
    if(!ValidatePositionRisk(signal.ticker, 0, price, sl)) {
        LogError(StringFormat(
            "Risk validation failed for %s signal before position sizing",
            signal.ticker
        ));
        return;
    }
   
   // Calculate position size based on risk
   double lotSize = CalculatePositionSize(signal.ticker, price, sl);
   if(lotSize == 0) {
      LogError("Error: Invalid lot size calculated");
      return;
   }

   // Final validation with actual lot size
    if(!ValidatePositionRisk(signal.ticker, lotSize, price, sl)) {
        LogError(StringFormat(
            "Final risk validation failed for %s with lot size %.2f",
            signal.ticker, lotSize
        ));
        return;
    }
   
   // Verify stop loss is valid
   if(cmd == OP_BUY && sl >= price) {
      LogError("Error: Invalid stop loss for BUY order - must be below entry price");
      return;
   }
   if(cmd == OP_SELL && sl <= price) {
      LogError("Error: Invalid stop loss for SELL order - must be above entry price");
      return;
   }
   
   double tp = 0;  // Take profit will be determined by profit protection
   
   // Determine price precision for logging
   bool isCryptoPair = (StringFind(signal.ticker, "BTC") >= 0 || 
                       StringFind(signal.ticker, "ETH") >= 0 || 
                       StringFind(signal.ticker, "LTC") >= 0);
   int digits = isCryptoPair ? 2 : (StringFind(signal.ticker, "JPY") >= 0 ? 3 : 5);

   if(isCryptoPair) {
    double positionValue = price * lotSize;
    double stopLossDifference = MathAbs(price - sl);
    double actualRisk = stopLossDifference * lotSize;
    double riskPercent = (actualRisk / AccountBalance()) * 100;
    
    if(riskPercent > MAX_SYMBOL_RISK_PERCENT) {
        LogError(StringFormat(
            "Trade rejected - Risk too high: %.2f%% vs maximum %.2f%%" +
            "\nSymbol: %s" +
            "\nLots: %.2f" +
            "\nRisk Amount: $%.2f",
            riskPercent, MAX_SYMBOL_RISK_PERCENT,
            signal.ticker, lotSize,
            actualRisk
        ));
        return;
    }
    
    // Check total account risk including this new position
    double totalAccountRisk = CalculateTotalAccountRisk() + actualRisk;
    double totalRiskPercent = (totalAccountRisk / AccountBalance()) * 100;
    
    if(totalRiskPercent > MAX_ACCOUNT_RISK_PERCENT) {
        LogError(StringFormat(
            "Trade rejected - Total account risk too high: %.2f%% vs maximum %.2f%%",
            totalRiskPercent, MAX_ACCOUNT_RISK_PERCENT
        ));
        return;
    }
}
   
   // Log trade details before execution
   LogTrade(StringFormat(
      "Placing new order:" +
      "\nSymbol: %s" +
      "\nType: %s" +
      "\nLots: %.2f" +
      "\nPrice: %.*f" +
      "\nStop Loss: %.*f" +
      "\nPattern: %s",
      signal.ticker,
      cmd == OP_BUY ? "BUY" : "SELL",
      lotSize,
      digits, price,
      digits, sl,
      signal.pattern
   ));
   
   // Place the order with retry logic
   int ticket = OrderSend(
      signal.ticker,          // Symbol
      cmd,                    // Operation
      lotSize,               // Lot size
      price,                 // Price
      MAX_SLIPPAGE,          // Slippage
      sl,                    // Stop Loss
      tp,                    // Take Profit
      signal.pattern,        // Comment
      0,                     // Magic Number
      0,                     // Expiration
      cmd == OP_BUY ? clrGreen : clrRed
   );
   
   // Handle order placement result
   if (ticket < 0) {
      int error = GetLastError();
      
      // Implement retry logic
      for(int retry = 1; retry <= MAX_RETRIES; retry++) {
         LogDebug("Retry " + IntegerToString(retry) + " of " + IntegerToString(MAX_RETRIES));
         
         RefreshRates();  // Get latest prices
         price = cmd == OP_BUY ? MarketInfo(signal.ticker, MODE_ASK) : 
                                MarketInfo(signal.ticker, MODE_BID);
         
         ticket = OrderSend(
            signal.ticker,
            cmd,
            lotSize,
            price,
            MAX_SLIPPAGE,
            sl,
            tp,
            signal.pattern,
            0,
            0,
            cmd == OP_BUY ? clrGreen : clrRed
         );
         
         if(ticket >= 0) break;  // Success
         Sleep(1000);  // Wait 1 second before retry
      }
      
      if(ticket < 0) {  // Still failed after retries
         error = GetLastError();
         LogError(StringFormat(
            "OrderSend failed after %d retries: Error %d" +
            "\nDescription: %s" +
            "\nSymbol: %s" +
            "\nLots: %.2f" +
            "\nPrice: %.*f",
            MAX_RETRIES,
            error,
            ErrorDescription(error),
            signal.ticker,
            lotSize,
            digits, price
         ));
      }
   }
   
   // Log successful trade
   if(ticket >= 0) {
      LogTrade(StringFormat(
         "Order placed successfully" +
         "\nTicket: %d" +
         "\nSymbol: %s" +
         "\nType: %s" +
         "\nLots: %.2f" +
         "\nPrice: %.*f",
         ticket,
         signal.ticker,
         signal.action,
         lotSize,
         digits, price
      ));
      lastSignalTimestamp = signal.timestamp;
   }
}

//+------------------------------------------------------------------+
//| Check and Protect Profitable Positions                             |
//+------------------------------------------------------------------+
void CheckProfitProtection() {
    static datetime lastProfitCheck = 0;
    datetime currentTime = TimeCurrent();
    
    if(currentTime - lastProfitCheck < PROFIT_CHECK_INTERVAL) return;
    lastProfitCheck = currentTime;
    
    if(!ENABLE_PROFIT_PROTECTION) return;
    
    for(int i = 0; i < OrdersTotal(); i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            string symbol = OrderSymbol();
            bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0);
            bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
            
            double openPrice = OrderOpenPrice();
            double currentPrice = OrderType() == OP_BUY ? 
                MarketInfo(symbol, MODE_BID) : 
                MarketInfo(symbol, MODE_ASK);
            double currentProfit = OrderProfit();
            
            if(isCryptoPair) {
                // Crypto pairs - use percentage
                double profitPercent = (currentProfit / (openPrice * OrderLots())) * 100;
                
                // Enhanced profit protection logic                
                if(profitPercent >= CRYPTO_PROFIT_THRESHOLD) {

                    // Calculate risk-adjusted lock price
                    double lockPrice;
                    if(OrderType() == OP_BUY) {
                        // Calculate minimum acceptable price for buy
                        lockPrice = openPrice * (1 + (CRYPTO_PROFIT_LOCK_PERCENT/100));

                        // Additional check for risk alignment
                        double potentialRisk = (lockPrice - openPrice) * OrderLots();
                        if((potentialRisk / AccountBalance()) * 100 > RISK_PERCENT) {
                            // Adjust lock price to maintain risk parameters
                            lockPrice = openPrice + (AccountBalance() * RISK_PERCENT / 100) / OrderLots();
                        }

                        if(currentPrice <= lockPrice) {
                            LogTrade(StringFormat(
                                "Profit Protection for %s" +
                                "\nProfit: %.2f%%" +
                                "\nLock Price: %.2f" +
                                "\nOriginal Lock: %.2f",
                                symbol, profitPercent, lockPrice,
                                openPrice * (1 + (CRYPTO_PROFIT_LOCK_PERCENT/100))
                            ));
                            CloseTradeWithProtection(OrderTicket(), "Lock Price profit protection");
                        }
                    } else {
                        // Calculate maximum acceptable price for sell
                        lockPrice = openPrice * (1 - (CRYPTO_PROFIT_LOCK_PERCENT/100));

                         double potentialRisk = (openPrice - lockPrice) * OrderLots();
                        if((potentialRisk / AccountBalance()) * 100 > RISK_PERCENT) {
                            lockPrice = openPrice - (AccountBalance() * RISK_PERCENT / 100) / OrderLots();
                        }

                        if(currentPrice >= lockPrice) {
                            LogTrade(StringFormat(
                                "Risk-Adjusted Profit Protection for %s" +
                                "\nProfit: %.2f%%" +
                                "\nRisk-Adjusted Lock: %.2f" +
                                "\nOriginal Lock: %.2f",
                                symbol, profitPercent, lockPrice,
                                openPrice * (1 - (CRYPTO_PROFIT_LOCK_PERCENT/100))
                            ));
                            CloseTradeWithProtection(OrderTicket(), "Risk-adjusted profit protection");
                        }
                    }
                }
            } else {
                // Forex pairs - use pips
                double pipSize = isJPYPair ? 0.01 : 0.0001;
                double profitInPips = MathAbs(currentPrice - openPrice) / pipSize;
                
                if(profitInPips >= FOREX_PROFIT_PIPS_THRESHOLD) {
                    double lockPrice;
                    if(OrderType() == OP_BUY) {
                        // Calculate minimum acceptable price for buy
                        lockPrice = openPrice + (FOREX_PROFIT_LOCK_PIPS * pipSize);
                        if(currentPrice <= lockPrice) {
                            LogTrade(StringFormat(
                                "Forex Profit Protection triggered for %s" +
                                "\nProfit: %.1f pips" +
                                "\nOpen Price: %.5f" +
                                "\nCurrent Price: %.5f" +
                                "\nLock Price: %.5f",
                                symbol, profitInPips, openPrice, currentPrice, lockPrice
                            ));
                            CloseTradeWithProtection(OrderTicket(), "Forex profit protection activated");
                        }
                    } else {
                        // Calculate maximum acceptable price for sell
                        lockPrice = openPrice - (FOREX_PROFIT_LOCK_PIPS * pipSize);
                        if(currentPrice >= lockPrice) {
                            LogTrade(StringFormat(
                                "Forex Profit Protection triggered for %s" +
                                "\nProfit: %.1f pips" +
                                "\nOpen Price: %.5f" +
                                "\nCurrent Price: %.5f" +
                                "\nLock Price: %.5f",
                                symbol, profitInPips, openPrice, currentPrice, lockPrice
                            ));
                            CloseTradeWithProtection(OrderTicket(), "Forex profit protection activated");
                        }
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Close Trade with Retry Protection                                  |
//+------------------------------------------------------------------+
bool CloseTradeWithProtection(int ticket, string reason) {
    if(!OrderSelect(ticket, SELECT_BY_TICKET)) {
        LogError("Failed to select order " + IntegerToString(ticket));
        return false;
    }
    
    string symbol = OrderSymbol();
    double lots = OrderLots();
    int type = OrderType();
    double openPrice = OrderOpenPrice();
    
    // Handle retry attempts
    bool success = false;
    for(int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        // Get fresh prices
        RefreshRates();  // Get latest prices
        double closePrice = type == OP_BUY ? 
            MarketInfo(symbol, MODE_BID) : 
            MarketInfo(symbol, MODE_ASK);
            
        // Calculate potential slippage based on pair type
        bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                            StringFind(symbol, "ETH") >= 0 || 
                            StringFind(symbol, "LTC") >= 0);
        int currentSlippage = isCryptoPair ? MAX_SLIPPAGE * 2 : MAX_SLIPPAGE;
        
        // Attempt to close the trade
        success = OrderClose(ticket, lots, closePrice, currentSlippage, clrRed);
        
        if(success) {
            double profit = OrderProfit();
            LogTrade(StringFormat(
                "Position closed successfully" +
                "\nTicket: %d" +
                "\nSymbol: %s" +
                "\nLots: %.2f" +
                "\nProfit: %.2f" +
                "\nReason: %s",
                ticket, symbol, lots, profit, reason
            ));
            break;
        }
        
        // Handle errors
        int error = GetLastError();
        switch(error) {
            case ERR_NO_CONNECTION:
            case ERR_COMMON_ERROR:
            case ERR_SERVER_BUSY:
            case ERR_NO_RESULT:
            case ERR_TRADE_TIMEOUT:
                Sleep(1000 * attempt); // Exponential backoff
                continue;
                
            case ERR_PRICE_CHANGED:
            case ERR_REQUOTE:
                RefreshRates();
                continue;
                
            case ERR_TRADE_CONTEXT_BUSY:
                Sleep(100);
                continue;
                
            default:
                LogError(StringFormat(
                    "Close attempt %d failed for ticket %d" +
                    "\nError: %d" +
                    "\nDescription: %s" +
                    "\nSymbol: %s" +
                    "\nClose Price: %.5f",
                    attempt, ticket, error, 
                    ErrorDescription(error), 
                    symbol, closePrice
                ));
                
                // If last retry, wait longer
                if(attempt < MAX_RETRIES) {
                    Sleep(1000 * attempt);
                    continue;
                }
        }
    }
    
    if(!success) {
        LogError(StringFormat(
            "CRITICAL: Failed to close position after %d attempts" +
            "\nTicket: %d" +
            "\nSymbol: %s" +
            "\nLots: %.2f",
            MAX_RETRIES, ticket, symbol, lots
        ));
    }
    
    return success;
}

//+------------------------------------------------------------------+
//| Check if we can open new positions based on risk management        |
//+------------------------------------------------------------------+
bool CanOpenNewPosition(string symbol) {
    // Check maximum positions per symbol
    int symbolPositions = 0;
    double totalRiskInSymbol = 0;
    double accountBalance = AccountBalance();
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0);
    
    // Calculate existing risk in this symbol
    for(int i = 0; i < OrdersTotal(); i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            if(OrderSymbol() == symbol) {
                symbolPositions++;
                
                // Calculate risk for this position
                double openPrice = OrderOpenPrice();
                double stopLoss = OrderStopLoss();
                double positionRisk;
                
                if(isCryptoPair) {
                    // Calculate actual risk based on stop loss
                    double positionValue = openPrice * OrderLots();
                    double stopLossDifference = MathAbs(openPrice - stopLoss);
                    double actualRisk = stopLossDifference * OrderLots();
                    double riskPercent = (actualRisk / AccountBalance()) * 100;
                    
                    // Calculate limits based on RISK_PERCENT
                    double maxSymbolRisk = AccountBalance() * (RISK_PERCENT * 2 / 100);
                    double maxAccountRisk = AccountBalance() * (RISK_PERCENT * 3 / 100);

                    if(actualRisk > maxSymbolRisk) {
                        LogWarning(StringFormat(
                            "Position risk exceeds per-symbol limit: $%.2f vs maximum $%.2f",
                            actualRisk, maxSymbolRisk
                        ));
                        return false;
                    }

                    positionRisk = actualRisk;

                } else {
                    // For forex, calculate pip risk
                    double pipSize = StringFind(symbol, "JPY") >= 0 ? 0.01 : 0.0001;
                    double pipValue = MarketInfo(symbol, MODE_TICKVALUE) * 10;
                    double pips = MathAbs(openPrice - stopLoss) / pipSize;
                    positionRisk = (pips * pipValue * OrderLots());
                }
                
                totalRiskInSymbol += positionRisk;
            }
        }
    }
    
    // Check position limit
    if(symbolPositions >= MAX_POSITIONS) {
        LogDebug(StringFormat(
            "Maximum positions (%d) reached for %s",
            MAX_POSITIONS, symbol
        ));
        return false;
    }
    
    // Calculate total account risk across all positions
    double totalAccountRisk = CalculateTotalAccountRisk();
    double accountRiskPercent = (totalAccountRisk / accountBalance) * 100;
    
    // Calculate risk percentages
    double symbolRiskPercent = (totalRiskInSymbol / accountBalance) * 100;

   // Define risk limits
    double maxSymbolRiskPercent = RISK_PERCENT * 2;    // Maximum 2x the risk per symbol (2% if RISK_PERCENT is 1%)
    
    // Log risk levels
    LogDebug(StringFormat(
        "Risk Analysis for %s:" +
        "\nPositions: %d/%d" +
        "\nSymbol Risk: %.2f%% (Max: %.2f%%)" +
        "\nAccount Risk: %.2f%% (Max: %.2f%%)" +
        "\nBalance: $%.2f",
        symbol, symbolPositions, MAX_POSITIONS,
        symbolRiskPercent, maxSymbolRiskPercent,
        accountRiskPercent, MAX_ACCOUNT_RISK_PERCENT,
        accountBalance
    ));
    
    // Check risk limits
    if(symbolRiskPercent >= maxSymbolRiskPercent) {
        LogWarning(StringFormat(
            "Maximum symbol risk reached for %s (%.2f%%)",
            symbol, symbolRiskPercent
        ));
        return false;
    }
    
    if(accountRiskPercent >= MAX_ACCOUNT_RISK_PERCENT) {
        LogWarning(StringFormat(
            "Maximum account risk reached (%.2f%%)",
            accountRiskPercent
        ));
        return false;
    }
    
    // Check margin requirements
    double marginRequired = MarketInfo(symbol, MODE_MARGINREQUIRED);
    double freeMargin = AccountFreeMargin();
    double marginLevel = AccountEquity() / AccountMargin() * 100;
    
    if(marginLevel < 150) {  // Minimum 150% margin level required
        LogWarning(StringFormat(
            "Insufficient margin level: %.2f%%",
            marginLevel
        ));
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Get the type of open position (OP_BUY or OP_SELL)                 |
//+------------------------------------------------------------------+
int GetOpenPositionType(string symbol) {
   for(int i = 0; i < OrdersTotal(); i++) {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
         if(OrderSymbol() == symbol) {
            return OrderType();
         }
      }
   }
   return -1;
}

//+------------------------------------------------------------------+
//| Close current position for the symbol                             |
//+------------------------------------------------------------------+
bool CloseCurrentPosition(string symbol) {
    int totalTries = MAX_RETRIES;  // Use consistent retry count from EA parameters
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0);
    int digits = isCryptoPair ? 2 : (StringFind(symbol, "JPY") >= 0 ? 3 : 5);
    
    for(int attempt = 1; attempt <= totalTries; attempt++) {
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
                LogError("Failed to select order at index " + IntegerToString(i));
                continue;
            }
            
            if(OrderSymbol() != symbol) continue;
            
            // Store order details before closing
            int ticket = OrderTicket();
            double lots = OrderLots();
            int type = OrderType();
            double openPrice = OrderOpenPrice();
            
            // Get fresh prices
            RefreshRates();
            double closePrice = type == OP_BUY ? MarketInfo(symbol, MODE_BID) : MarketInfo(symbol, MODE_ASK);
            
            // Calculate appropriate slippage based on pair type
            int currentSlippage = isCryptoPair ? MAX_SLIPPAGE * 2 : MAX_SLIPPAGE * attempt;
            
            LogTrade(StringFormat(
                "Attempting to close position (Attempt %d/%d):" +
                "\nTicket: %d" +
                "\nSymbol: %s" +
                "\nType: %s" +
                "\nLots: %.2f" +
                "\nOpen Price: %.*f" +
                "\nClose Price: %.*f" +
                "\nSlippage: %d",
                attempt, totalTries,
                ticket, symbol,
                type == OP_BUY ? "BUY" : "SELL",
                lots,
                digits, openPrice,
                digits, closePrice,
                currentSlippage
            ));
            
            bool success = OrderClose(ticket, lots, closePrice, currentSlippage, clrRed);
            
            if(!success) {
                int error = GetLastError();
                
                // Handle specific error cases
               switch(error) {
                  case ERR_NO_CONNECTION:
                  case ERR_COMMON_ERROR:
                  case ERR_SERVER_BUSY:
                  case ERR_TRADE_TIMEOUT:
                     Sleep(1000 * attempt);  // Exponential backoff
                     RefreshRates();
                     continue;
                     
                  case ERR_PRICE_CHANGED:
                  case ERR_REQUOTE:
                     RefreshRates();
                     continue;
                     
                  case ERR_TRADE_CONTEXT_BUSY:
                     Sleep(100);
                     continue;
                     
                  default:
                     LogError(StringFormat(
                           "Close failed - Attempt %d/%d" +
                           "\nError: %d" +
                           "\nDescription: %s" +
                           "\nTicket: %d" +
                           "\nSymbol: %s",
                           attempt, totalTries,
                           error, ErrorDescription(error),
                           ticket, symbol
                     ));
               }
            } else {
                double profit = OrderProfit() + OrderSwap() + OrderCommission();
                LogTrade(StringFormat(
                    "Position closed successfully:" +
                    "\nTicket: %d" +
                    "\nSymbol: %s" +
                    "\nProfit: %.2f" +
                    "\nAttempts needed: %d",
                    ticket, symbol, profit, attempt
                ));
                return true;
            }
        }
        
        // If we reach here, sleep before next attempt
        if(attempt < totalTries) {
            Sleep(1000 * attempt);
            RefreshRates();
        }
    }
    
    LogError(StringFormat(
        "Failed to close position after %d attempts for %s",
        totalTries, symbol
    ));
    return false;
}

//+------------------------------------------------------------------+
//| Check if symbol has open position                                 |
//+------------------------------------------------------------------+
bool HasOpenPosition(string symbol) {
    int total = 0;
    double totalVolume = 0;
    int buyPositions = 0;
    int sellPositions = 0;
    
    for(int i = 0; i < OrdersTotal(); i++) {
        if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            LogError("Failed to select order - error: " + ErrorDescription(GetLastError()));
            continue;
        }
        
        if(OrderSymbol() == symbol && (OrderType() == OP_BUY || OrderType() == OP_SELL)) {
            total++;
            totalVolume += OrderLots();
            
            if(OrderType() == OP_BUY) buyPositions++;
            if(OrderType() == OP_SELL) sellPositions++;
        }
    }
    
    if(total > 0) {
        LogDebug(StringFormat(
            "Open positions for %s:" +
            "\nTotal Positions: %d" +
            "\nBuy Positions: %d" +
            "\nSell Positions: %d" +
            "\nTotal Volume: %.2f",
            symbol, total, buyPositions, sellPositions, totalVolume
        ));
        
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Get detailed position information                                  |
//+------------------------------------------------------------------+
bool GetPositionDetails(string symbol, int &positionCount, double &totalVolume, 
                       int &buyCount, int &sellCount, double &avgPrice) {
    positionCount = 0;
    totalVolume = 0;
    buyCount = 0;
    sellCount = 0;
    double weightedPrice = 0;
    
    for(int i = 0; i < OrdersTotal(); i++) {
        if(!OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            LogError("Failed to select order - error: " + ErrorDescription(GetLastError()));
            continue;
        }
        
        if(OrderSymbol() == symbol && (OrderType() == OP_BUY || OrderType() == OP_SELL)) {
            positionCount++;
            double lots = OrderLots();
            totalVolume += lots;
            weightedPrice += OrderOpenPrice() * lots;
            
            if(OrderType() == OP_BUY) buyCount++;
            if(OrderType() == OP_SELL) sellCount++;
        }
    }
    
    if(positionCount > 0) {
        avgPrice = weightedPrice / totalVolume;
        
        LogDebug(StringFormat(
            "Position Details for %s:" +
            "\nTotal Positions: %d" +
            "\nBuy Positions: %d" +
            "\nSell Positions: %d" +
            "\nTotal Volume: %.2f" +
            "\nAverage Price: %.5f",
            symbol, positionCount, buyCount, sellCount, totalVolume, avgPrice
        ));
        
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Helper function to extract JSON values                            |
//+------------------------------------------------------------------+
string GetJsonValue(string &json, string key) {
   string search = "\"" + key + "\":\"";
   int start = StringFind(json, search);
   if(start == -1) {
      // Try without quotes (for numbers)
      search = "\"" + key + "\":";
      start = StringFind(json, search);
      if(start == -1) return "";
   }
   
   start += StringLen(search);
   int end = StringFind(json, "\"", start);
   if(end == -1) {
      // Try finding comma for numbers
      end = StringFind(json, ",", start);
      if(end == -1) end = StringFind(json, "}", start);
      if(end == -1) return "";
   }
   
   return StringSubstr(json, start, end - start);
}

//+------------------------------------------------------------------+
//| Get detailed error description                                     |
//+------------------------------------------------------------------+
string ErrorDescription(int error_code) {
   string error_string;
   
   switch(error_code) {
      // Custom Error Messages
      case ERR_CUSTOM_START:            error_string = "Custom error";                                         break;
      case ERR_CUSTOM_START + 1:        error_string = "Resource not found";                                   break;
      case ERR_CUSTOM_START + 2:        error_string = "Authorization error";                                  break;
      case ERR_CUSTOM_START + 3:        error_string = "Object already exists";                                break;
      case ERR_CUSTOM_START + 4:        error_string = "Object does not exist";                               break;
      
      default: error_string = StringFormat("Unknown error (%d)", error_code);                                  break;
   }
   
   return StringFormat("Error %d: %s", error_code, error_string);
}

//+------------------------------------------------------------------+
//| Get error severity level                                           |
//+------------------------------------------------------------------+
string GetErrorSeverity(int error_code) {
    switch(error_code) {
        // Critical Errors
        case ERR_CUSTOM_START + 1:
        case ERR_CUSTOM_START + 2:
            return "CRITICAL";
            
        // Serious Errors
        case ERR_CUSTOM_START + 3:
        case ERR_CUSTOM_START + 4:
            return "SERIOUS";
            
        default:
            return "UNKNOWN";
    }
}

//+------------------------------------------------------------------+
//| Check if market is open for trading                               |
//+------------------------------------------------------------------+
bool IsMarketOpen(string symbol) {
      // Initial broker connectivity check
    datetime symbolTime = (datetime)MarketInfo(symbol, MODE_TIME);
    if(symbolTime == 0) {
        LogError("Cannot get market time for " + symbol);
        return false;
    }
    
    // Check if it's a holiday
    if(IsForexHoliday(TimeCurrent())) {
        LogDebug("Market closed - Holiday");
        return false;
    }
    
    // Weekend check (except for crypto)
    if(StringFind(symbol, "BTC") == -1 && StringFind(symbol, "ETH") == -1 && StringFind(symbol, "LTC") == -1) {
        int dayOfWeek = TimeDayOfWeek(TimeCurrent());
        if(dayOfWeek == SATURDAY || dayOfWeek == SUNDAY) {
            LogDebug("Market closed - Weekend for " + symbol);
            return false;
        }
    }

   return IsMarketSessionActive(symbol);

}

//+------------------------------------------------------------------+
//| Check if market session is active                                  |
//+------------------------------------------------------------------+
bool IsMarketSessionActive(string symbol) {
    if(StringFind(symbol, "BTC") >= 0 || StringFind(symbol, "ETH") >= 0 || StringFind(symbol, "LTC") >= 0) {
        return true;  // Crypto trades 24/7
    }
    
    datetime serverTime = TimeCurrent();
    int serverHour = TimeHour(serverTime);
    
    // Define major trading sessions (All times in server time)
    // Sydney/Tokyo (Asian Session)
    bool isAsianSession = (serverHour >= 22 || serverHour < 8);    // 22:00 - 08:00
    
    // London (European Session)
    bool isLondonSession = (serverHour >= 8 && serverHour < 16);   // 08:00 - 16:00
    
    // New York Session
    bool isNewYorkSession = (serverHour >= 13 && serverHour < 22); // 13:00 - 22:00
    
    // Major Session Overlaps
    bool isLondonNYOverlap = (serverHour >= 13 && serverHour < 16); // London/NY Overlap
    bool isAsianLondonOverlap = (serverHour >= 7 && serverHour < 9); // Asian/London Overlap
    
    // Calculate session status and liquidity
    string currentSession = "";
    string liquidityLevel = "Normal";
    
    if(isLondonNYOverlap) {
        currentSession = "London/New York Overlap";
        liquidityLevel = "High";
    }
    else if(isAsianLondonOverlap) {
        currentSession = "Asian/London Overlap";
        liquidityLevel = "High";
    }
    else if(isLondonSession) {
        currentSession = "London";
        liquidityLevel = "High";
    }
    else if(isNewYorkSession) {
        currentSession = "New York";
        liquidityLevel = "High";
    }
    else if(isAsianSession) {
        currentSession = "Asian";
        liquidityLevel = isLondonSession ? "High" : "Moderate";
    }
    else {
        currentSession = "Off-Hours";
        liquidityLevel = "Low";
    }
    
    // Log session information
    LogDebug(StringFormat(
        "Session Status for %s:" +
        "\nCurrent Session: %s" +
        "\nLiquidity Level: %s" +
        "\nTime: %s",
        symbol,
        currentSession,
        liquidityLevel,
        TimeToString(serverTime)
    ));
    
    // Special handling for currency pairs
    bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
    bool isGBPPair = (StringFind(symbol, "GBP") >= 0);
    bool isEURPair = (StringFind(symbol, "EUR") >= 0);
    
    if(isJPYPair && !isAsianSession && !isAsianLondonOverlap) {
        LogWarning("Trading JPY pair outside Asian session - Reduced liquidity possible");
    }
    if(isGBPPair && !isLondonSession && !isLondonNYOverlap) {
        LogWarning("Trading GBP pair outside London session - Reduced liquidity possible");
    }
    if(isEURPair && !isLondonSession && !isLondonNYOverlap) {
        LogWarning("Trading EUR pair outside European session - Reduced liquidity possible");
    }
    
    // Determine if trading should be allowed
    bool sessionAllowed = false;
    
    if(ALLOW_SESSION_OVERLAP && (isLondonNYOverlap || isAsianLondonOverlap)) {
        sessionAllowed = true;  // Always allow during major overlaps if enabled
    }
    else {
        sessionAllowed = (isAsianSession && TRADE_ASIAN_SESSION) ||
                        (isLondonSession && TRADE_LONDON_SESSION) ||
                        (isNewYorkSession && TRADE_NEWYORK_SESSION);
    }
    
    return sessionAllowed;
}

//+------------------------------------------------------------------+
//| Check if date is a forex market holiday                           |
//+------------------------------------------------------------------+
bool IsForexHoliday(datetime serverTime) {
    int year = TimeYear(serverTime);
    int month = TimeMonth(serverTime);
    int day = TimeDay(serverTime);
    int dayOfWeek = TimeDayOfWeek(serverTime);
    
    // New Year's Eve and New Year's Day
    if((month == 12 && day == 31) || (month == 1 && day == 1)) {
        LogDebug("Forex Holiday: New Year's");
        return true;
    }
    
    // Christmas and Boxing Day
    if(month == 12 && (day == 24 || day == 25 || day == 26)) {
        LogDebug("Forex Holiday: Christmas Period");
        return true;
    }
    
    // Fixed Date Holidays
    if((month == 1 && day == 1)  ||    // New Year's Day
       (month == 5 && day == 1)  ||    // Labor Day (Many European Markets)
       (month == 7 && day == 4)  ||    // Independence Day (US Markets)
       (month == 12 && day == 25) ||   // Christmas
       (month == 12 && day == 26)) {   // Boxing Day
        LogDebug("Forex Holiday: Fixed Date Holiday");
        return true;
    }
    
    // US Holidays (affecting major forex trading)
    // Martin Luther King Jr. Day (Third Monday in January)
    if(month == 1 && dayOfWeek == MONDAY && day >= 15 && day <= 21) {
        LogDebug("Forex Holiday: Martin Luther King Jr. Day");
        return true;
    }
    
    // Presidents Day (Third Monday in February)
    if(month == 2 && dayOfWeek == MONDAY && day >= 15 && day <= 21) {
        LogDebug("Forex Holiday: Presidents Day");
        return true;
    }
    
    // Memorial Day (Last Monday in May)
    if(month == 5 && dayOfWeek == MONDAY && day >= 25 && day <= 31) {
        LogDebug("Forex Holiday: Memorial Day");
        return true;
    }
    
    // Independence Day (July 4 - if weekend, observed on closest weekday)
    if(month == 7) {
        if(day == 4 || 
           (day == 3 && dayOfWeek == FRIDAY) || 
           (day == 5 && dayOfWeek == MONDAY)) {
            LogDebug("Forex Holiday: Independence Day");
            return true;
        }
    }
    
    // Labor Day US (First Monday in September)
    if(month == 9 && dayOfWeek == MONDAY && day <= 7) {
        LogDebug("Forex Holiday: Labor Day (US)");
        return true;
    }
    
    // Columbus Day (Second Monday in October)
    if(month == 10 && dayOfWeek == MONDAY && day >= 8 && day <= 14) {
        LogDebug("Forex Holiday: Columbus Day");
        return true;
    }
    
    // Veterans Day (November 11)
    if(month == 11 && day == 11) {
        LogDebug("Forex Holiday: Veterans Day");
        return true;
    }
    
    // Thanksgiving (Fourth Thursday in November) and Black Friday
    if(month == 11 && dayOfWeek == THURSDAY && day >= 22 && day <= 28) {
        LogDebug("Forex Holiday: Thanksgiving");
        return true;
    }
    if(month == 11 && dayOfWeek == FRIDAY && day >= 23 && day <= 29) {
        LogDebug("Forex Holiday: Black Friday");
        return true;
    }
    
    // Good Friday (approximate - varies each year)
    // Note: This is a rough approximation. Good Friday can occur between March 20 and April 23
    if((month == 3 || month == 4) && dayOfWeek == FRIDAY) {
        int easterMonth = GetEasterMonth(year);
        int easterDay = GetEasterDay(year);
        
        // Good Friday is 2 days before Easter
        if(month == easterMonth && day == easterDay - 2) {
            LogDebug("Forex Holiday: Good Friday");
            return true;
        }
    }
    
    // Easter Monday
    if((month == 3 || month == 4) && dayOfWeek == MONDAY) {
        int easterMonth = GetEasterMonth(year);
        int easterDay = GetEasterDay(year);
        
        if(month == easterMonth && day == easterDay + 1) {
            LogDebug("Forex Holiday: Easter Monday");
            return true;
        }
    }
    
    // Bank Holidays (UK)
    // Early May Bank Holiday (First Monday in May)
    if(month == 5 && dayOfWeek == MONDAY && day <= 7) {
        LogDebug("Forex Holiday: Early May Bank Holiday (UK)");
        return true;
    }
    
    // Spring Bank Holiday (Last Monday in May)
    if(month == 5 && dayOfWeek == MONDAY && day >= 25) {
        LogDebug("Forex Holiday: Spring Bank Holiday (UK)");
        return true;
    }
    
    // Summer Bank Holiday (Last Monday in August)
    if(month == 8 && dayOfWeek == MONDAY && day >= 25) {
        LogDebug("Forex Holiday: Summer Bank Holiday (UK)");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Helper function to get Easter month for a given year              |
//+------------------------------------------------------------------+
int GetEasterMonth(int year) {
    // Simplified Meeus/Jones/Butcher algorithm
    int a = year % 19;
    int b = year / 100;
    int c = year % 100;
    int d = b / 4;
    int e = b % 4;
    int f = (b + 8) / 25;
    int g = (b - f + 1) / 3;
    int h = (19 * a + b - d - g + 15) % 30;
    int i = c / 4;
    int k = c % 4;
    int l = (32 + 2 * e + 2 * i - h - k) % 7;
    int m = (a + 11 * h + 22 * l) / 451;
    
    return (h + l - 7 * m + 114) / 31;
}

//+------------------------------------------------------------------+
//| Helper function to get Easter day for a given year                |
//+------------------------------------------------------------------+
int GetEasterDay(int year) {
    // Simplified Meeus/Jones/Butcher algorithm
    int a = year % 19;
    int b = year / 100;
    int c = year % 100;
    int d = b / 4;
    int e = b % 4;
    int f = (b + 8) / 25;
    int g = (b - f + 1) / 3;
    int h = (19 * a + b - d - g + 15) % 30;
    int i = c / 4;
    int k = c % 4;
    int l = (32 + 2 * e + 2 * i - h - k) % 7;
    int m = (a + 11 * h + 22 * l) / 451;
    
    return ((h + l - 7 * m + 114) % 31) + 1;
}

//+------------------------------------------------------------------+
//| Helper function to remove "+" suffix from symbol                  |
//+------------------------------------------------------------------+
string GetBaseSymbol(string symbol) {
   // Remove the "+" suffix if it exists
   int plusPos = StringFind(symbol, "+");
   if(plusPos != -1) {
      return StringSubstr(symbol, 0, plusPos);
   }
   return symbol;
}

// Helper function to calculate total account risk
double CalculateTotalAccountRisk() {
    double totalRisk = 0;
    
    for(int i = 0; i < OrdersTotal(); i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            string symbol = OrderSymbol();
            bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                               StringFind(symbol, "ETH") >= 0 || 
                               StringFind(symbol, "LTC") >= 0);
            
            double openPrice = OrderOpenPrice();
            double stopLoss = OrderStopLoss();
            double riskDistance = MathAbs(openPrice - stopLoss);
            
            if(isCryptoPair) {
                totalRisk += riskDistance * OrderLots();
            } else {
                bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
                double pipSize = isJPYPair ? 0.01 : 0.0001;
                double pipValue = MarketInfo(symbol, MODE_TICKVALUE) * 
                                (isJPYPair ? 100 : 10);
                double pips = riskDistance / pipSize;
                totalRisk += (pips * pipValue * OrderLots());
            }
        }
    }
    
    return totalRisk;
}

// Helper function to validate position risk
bool ValidatePositionRisk(string symbol, double lots, double entryPrice, double stopLoss) {
    double accountBalance = AccountBalance();
    double stopDistance = MathAbs(entryPrice - stopLoss);
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                        StringFind(symbol, "ETH") >= 0 || 
                        StringFind(symbol, "LTC") >= 0);
    
    // Calculate position risk
    double positionRisk = 0;  // Initialize the variable
    
    if(isCryptoPair) {
        // For crypto pairs, calculate risk in currency terms
        positionRisk = stopDistance * lots;
    } else {
        // For forex pairs, calculate risk in currency terms based on pip value
        bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
        double pipSize = isJPYPair ? 0.01 : 0.0001;
        double pipValue = MarketInfo(symbol, MODE_TICKVALUE) * (isJPYPair ? 100 : 10);
        double pips = stopDistance / pipSize;
        positionRisk = (pips * pipValue * lots);
    }
    
    // Calculate risk percentage for this position
    double positionRiskPercent = (positionRisk / accountBalance) * 100;
    
    // Check if position risk exceeds maximum allowed per symbol
    if(positionRiskPercent > MAX_SYMBOL_RISK_PERCENT) {
        LogError(StringFormat(
            "Position risk too high: %.2f%% (max %.2f%%)",
            positionRiskPercent, MAX_SYMBOL_RISK_PERCENT
        ));
        return false;
    }
    
    // Calculate total account risk including this new position
    double existingRisk = CalculateTotalAccountRisk();
    double totalRisk = existingRisk + positionRisk;
    double totalRiskPercent = (totalRisk / accountBalance) * 100;
    
    // Check if total account risk exceeds maximum allowed
    if(totalRiskPercent > MAX_ACCOUNT_RISK_PERCENT) {
        LogError(StringFormat(
            "Total account risk too high: %.2f%% (max %.2f%%)",
            totalRiskPercent, MAX_ACCOUNT_RISK_PERCENT
        ));
        return false;
    }
    
    LogDebug(StringFormat(
        "Risk Validation Passed:" +
        "\nPosition Risk: $%.2f (%.2f%%)" +
        "\nTotal Account Risk: $%.2f (%.2f%%)",
        positionRisk, positionRiskPercent,
        totalRisk, totalRiskPercent
    ));
    
    return true;
}


//+------------------------------------------------------------------+
//| Helper function to monitor risk levels                             |
//+------------------------------------------------------------------+
void MonitorRiskLevels() {
    static datetime lastWarningTime = 0;  // Track last warning time
    datetime currentTime = TimeCurrent();
    
    double accountBalance = AccountBalance();
    double totalRisk = CalculateTotalAccountRisk();
    double currentRiskPercent = (totalRisk / accountBalance) * 100;
    
    // Log risk levels periodically (every 5 minutes)
    static datetime lastRiskCheck = 0;
    if(TimeCurrent() - lastRiskCheck >= 300) {  // Every 5 minutes
        LogDebug(StringFormat(
            "Current Risk Levels:" +
            "\nTotal Risk: $%.2f" +
            "\nRisk Percent: %.2f%%" +
            "\nMax Allowed: %.2f%%",
            totalRisk, currentRiskPercent, MAX_ACCOUNT_RISK_PERCENT
        ));
        lastRiskCheck = TimeCurrent();
    }
    
    // Alert on high risk levels - only warn every 5 minutes
    if(currentRiskPercent > MAX_ACCOUNT_RISK_PERCENT * 0.8) {  // Warning at 80% of max
        if(currentTime - lastWarningTime >= 300) {  // 5 minutes between warnings
            LogWarning(StringFormat(
                "High Risk Level Alert:" +
                "\nCurrent Risk: %.2f%%" +
                "\nMax Allowed: %.2f%%",
                currentRiskPercent, MAX_ACCOUNT_RISK_PERCENT
            ));
            lastWarningTime = currentTime;
        }
    }
}

//+------------------------------------------------------------------+
//| Emergency close check                                             |
//+------------------------------------------------------------------+
// In CheckEmergencyClose:
void CheckEmergencyClose() {
   for(int i = 0; i < OrdersTotal(); i++) {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
         string symbol = OrderSymbol();
         bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                            StringFind(symbol, "ETH") >= 0 || 
                            StringFind(symbol, "LTC") >= 0);
         bool isJPYPair = (StringFind(symbol, "JPY") >= 0);
         
         double openPrice = OrderOpenPrice();
         double currentPrice = OrderType() == OP_BUY ? 
            MarketInfo(symbol, MODE_BID) : 
            MarketInfo(symbol, MODE_ASK);
            
         if(isCryptoPair) {
             // Calculate ACTUAL position loss (not potential risk)
             double currentValue = currentPrice * OrderLots();
             double openValue = openPrice * OrderLots();
             double actualLoss = MathAbs(currentValue - openValue);
             double lossPercent = (actualLoss / openValue) * 100;  // Calculate loss as percentage of position size
             
             // Emergency close triggers
             bool emergencyClose = false;
             string reason = "";
             
             // Only close if actual loss exceeds threshold
             if(lossPercent >= EMERGENCY_CLOSE_PERCENT) {
                 emergencyClose = true;
                 reason = "Actual loss exceeded emergency threshold";
             }
             
             // Fixed: Remove the total risk check that was causing premature closure
             
             if(emergencyClose) {
                 LogError(StringFormat(
                     "CRYPTO EMERGENCY CLOSE triggered for %s" +
                     "\nReason: %s" +
                     "\nActual Loss: %.2f%%" +
                     "\nOpen Price: %.2f" +
                     "\nCurrent Price: %.2f",
                     symbol, reason, lossPercent, openPrice, currentPrice
                 ));
                 CloseCurrentPosition(symbol);
             }
         } else {
             // Forex pip-based logic
             double pipSize = isJPYPair ? 0.01 : 0.0001;
             double pipLoss = MathAbs(currentPrice - openPrice) / pipSize;
             
             if(pipLoss >= FOREX_EMERGENCY_PIPS) {
                LogError(StringFormat(
                   "FOREX EMERGENCY CLOSE triggered for %s" +
                   "\nOpen Price: %.5f" +
                   "\nCurrent Price: %.5f" +
                   "\nPip Loss: %.1f pips" +
                   "\nEmergency Threshold: %.1f pips",
                   symbol, openPrice, currentPrice, pipLoss, FOREX_EMERGENCY_PIPS
                ));
                
                CloseCurrentPosition(symbol);
             }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Log Account Performance Metrics                                    |
//+------------------------------------------------------------------+
void LogAccountStatus() {
    string metrics = StringFormat(
        "Account Performance Metrics:" +
        "\nBalance: %.2f" +
        "\nEquity: %.2f" +
        "\nFloating P/L: %.2f" +
        "\nMargin Used: %.2f" +
        "\nFree Margin: %.2f" +
        "\nMargin Level: %.2f%%",
        AccountBalance(),
        AccountEquity(),
        AccountEquity() - AccountBalance(),
        AccountMargin(),
        AccountFreeMargin(),
        AccountMargin() != 0 ? (AccountEquity() / AccountMargin()) * 100 : 0
    );
    
    LogInfo(metrics);
}

//+------------------------------------------------------------------+
//| Log Daily Performance Summary                                      |
//+------------------------------------------------------------------+
void LogDailyPerformance() {
    static datetime lastDayChecked = 0;
    datetime currentTime = TimeCurrent();
    
    // Only log once per day
    if(TimeDay(currentTime) == TimeDay(lastDayChecked)) return;
    
    double totalProfit = 0;
    int totalTrades = 0;
    int winningTrades = 0;
    
    // Calculate daily statistics
    for(int i = OrdersHistoryTotal() - 1; i >= 0; i--) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) {
            if(TimeDay(OrderCloseTime()) == TimeDay(currentTime)) {
                totalProfit += OrderProfit() + OrderSwap() + OrderCommission();
                totalTrades++;
                if(OrderProfit() > 0) winningTrades++;
            }
        }
    }
    
    string summary = StringFormat(
        "Daily Performance Summary:" +
        "\nDate: %s" +
        "\nTotal Profit/Loss: %.2f" +
        "\nTotal Trades: %d" +
        "\nWinning Trades: %d" +
        "\nWin Rate: %.2f%%",
        TimeToString(currentTime, TIME_DATE),
        totalProfit,
        totalTrades,
        winningTrades,
        totalTrades > 0 ? (winningTrades * 100.0 / totalTrades) : 0
    );
    
    LogInfo(summary);
    lastDayChecked = currentTime;
}

//+------------------------------------------------------------------+
//| Log Market Conditions                                             |
//+------------------------------------------------------------------+
void LogMarketConditions(string symbol) {
    double spread = MarketInfo(symbol, MODE_SPREAD) * MarketInfo(symbol, MODE_POINT);
    string conditions = StringFormat(
        "Market Conditions for %s:" +
        "\nBid: %.5f" +
        "\nAsk: %.5f" +
        "\nSpread: %.5f" +
        "\nDigits: %d" +
        "\nPip Value: %.5f" +
        "\nMin Lot: %.2f" +
        "\nMax Lot: %.2f" +
        "\nLot Step: %.2f",
        symbol,
        MarketInfo(symbol, MODE_BID),
        MarketInfo(symbol, MODE_ASK),
        spread,
        (int)MarketInfo(symbol, MODE_DIGITS),
        MarketInfo(symbol, MODE_TICKVALUE),
        MarketInfo(symbol, MODE_MINLOT),
        MarketInfo(symbol, MODE_MAXLOT),
        MarketInfo(symbol, MODE_LOTSTEP)
    );
    
    LogInfo(conditions, symbol);
}

//+------------------------------------------------------------------+
//| Log Trading Volume                                                |
//+------------------------------------------------------------------+
void LogTradingVolume(string symbol) {
    long currentVolume = (long)iVolume(symbol, PERIOD_CURRENT, 0);
    long previousVolume = (long)iVolume(symbol, PERIOD_CURRENT, 1);
    
    string volumeInfo = StringFormat(
        "Trading Volume for %s:" +
        "\nCurrent Bar Volume: %I64d" +
        "\nPrevious Bar Volume: %I64d",
        symbol,
        currentVolume,
        previousVolume
    );
    
    LogDebug(volumeInfo, symbol);
}