// Adding new constants for instrument specifications
#define CRYPTO_DIGITS 2          // Crypto pairs digits
#define FOREX_DIGITS 5           // Forex pairs digits
#define LTC_CONTRACT_SIZE 100    // LTCUSD contract size
#define BTC_ETH_CONTRACT_SIZE 1  // BTCUSD and ETHUSD contract size
#define FOREX_MAX_SPREAD 0.00025 // Maximum allowed spread for forex (8 pips for 5-digit pairs)
#define CRYPTO_MAX_SPREAD 8.0    // Maximum allowed spread for crypto pairs (2-digit pairs)

//+------------------------------------------------------------------+
//| Helper function to check spread conditions                         |
//+------------------------------------------------------------------+
bool IsSpreadAcceptable(string symbol) {
    double currentSpread = MarketInfo(symbol, MODE_SPREAD) * MarketInfo(symbol, MODE_POINT);
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                        StringFind(symbol, "ETH") >= 0 || 
                        StringFind(symbol, "LTC") >= 0);
    
    double maxAllowedSpread = isCryptoPair ? CRYPTO_MAX_SPREAD : FOREX_MAX_SPREAD;
    
    if(currentSpread > maxAllowedSpread) {
        LogWarning(StringFormat(
            "Spread too high for %s: Current: %.5f, Maximum: %.5f",
            symbol, currentSpread, maxAllowedSpread
        ));
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Calculate position size based on risk and stop loss                |
//+------------------------------------------------------------------+
double CalculatePositionSize(string symbol, double entryPrice, double stopLoss) {
    // Calculate maximum risk amount based on account balance
    double accountBalance = AccountBalance();
    double maxRiskAmount = accountBalance * (RISK_PERCENT / 100);

    // Calculate stop loss distance in price terms
    double stopDistance = MathAbs(entryPrice - stopLoss);

    if (stopDistance == 0) {
        LogError("Error: Stop loss distance cannot be zero");
        return 0;
    }

    // Identify pair type
    bool isCryptoPair = (StringFind(symbol, "BTC") >= 0 || 
                        StringFind(symbol, "ETH") >= 0 || 
                        StringFind(symbol, "LTC") >= 0);
    bool isJPYPair = (StringFind(symbol, "JPY") >= 0);

    // Get contract size based on symbol
    double contractSize = 1.0;
    if(StringFind(symbol, "LTC") >= 0) {
        contractSize = LTC_CONTRACT_SIZE;
    } else if(isCryptoPair) {
        contractSize = BTC_ETH_CONTRACT_SIZE;
    }

    LogDebug(StringFormat(
        "Position Size Calculation Starting:" +
        "\nSymbol: %s" +
        "\nContract Size: %.2f" +
        "\nAccount Balance: $%.2f" +
        "\nRisk Amount: $%.2f" +
        "\nEntry Price: %.5f" +
        "\nStop Loss: %.5f" +
        "\nStop Distance: %.5f",
        symbol, contractSize, accountBalance, maxRiskAmount, 
        entryPrice, stopLoss, stopDistance), symbol);

    double lotSize;

    if (isCryptoPair) {
        // CRYPTO POSITION SIZING
        double oneUnitValue = entryPrice * contractSize;
        
        // Calculate true USD risk per lot considering contract size
        double riskPerLot = stopDistance * oneUnitValue;
        
        // Initial lot size based on risk
        lotSize = maxRiskAmount / riskPerLot;
        
        // Maximum position value based on RISK_PERCENT
        double maxPositionValue = AccountEquity() * (RISK_PERCENT * 2 / 100);
        double maxLotsBasedOnEquity = maxPositionValue / oneUnitValue;
        
        // Margin checks
        double marginRequired = MarketInfo(symbol, MODE_MARGINREQUIRED);
        if (marginRequired > 0) {
            double maxLotsBasedOnMargin = AccountFreeMargin() / (marginRequired * 1.5);
            maxLotsBasedOnEquity = MathMin(maxLotsBasedOnEquity, maxLotsBasedOnMargin);
            
            LogDebug(StringFormat(
                "Margin Calculations:" +
                "\nMargin Required: %.2f" +
                "\nFree Margin: %.2f" +
                "\nMax Lots (Margin): %.4f",
                marginRequired, AccountFreeMargin(), maxLotsBasedOnMargin));
        }
        
        // Take the minimum of risk-based size and safety limits
        lotSize = MathMin(lotSize, maxLotsBasedOnEquity);
        
        // Apply broker limits
        double minLot = MarketInfo(symbol, MODE_MINLOT);
        double maxLot = MarketInfo(symbol, MODE_MAXLOT);
        lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
        
        // Calculate actual risk for verification
        double actualRiskAmount = lotSize * riskPerLot;
        double actualRiskPercent = (actualRiskAmount / AccountBalance()) * 100;
        
        LogDebug(StringFormat(
            "Crypto Position Size Calculation:" +
            "\nContract Size: %.2f" +
            "\nOne Unit Value: $%.2f" +
            "\nRisk Per Lot: $%.2f" +
            "\nInitial Size: %.4f" +
            "\nMax Size Based on Equity: %.4f" +
            "\nFinal Size: %.4f" +
            "\nActual Risk Amount: $%.2f" +
            "\nActual Risk Percent: %.2f%%",
            contractSize,
            oneUnitValue,
            riskPerLot,
            maxRiskAmount / riskPerLot,
            maxLotsBasedOnEquity,
            lotSize,
            actualRiskAmount,
            actualRiskPercent
        ));
        
    } else {
        // Rest of the existing forex position sizing logic remains unchanged
        // ... [Previous forex calculation code]
    }
    
    return lotSize;
}

//+------------------------------------------------------------------+
//| Process trading signal                                            |
//+------------------------------------------------------------------+
void ProcessSignal(SignalData &signal) {
    // Initial symbol validation
    if (MarketInfo(signal.ticker, MODE_BID) == 0) {
        LogError(StringFormat("Error: Invalid symbol %s", signal.ticker));
        return;
    }

    // Check spread conditions before processing
    if (!IsSpreadAcceptable(signal.ticker)) {
        LogWarning(StringFormat("Trade skipped for %s due to high spread", signal.ticker));
        return;
    }

    // Rest of the existing ProcessSignal logic
    // ... [Previous ProcessSignal code]
}